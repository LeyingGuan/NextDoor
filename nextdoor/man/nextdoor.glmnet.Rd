% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/nextdoor_glmnet.R
\name{nextdoor.glmnet}
\alias{nextdoor.glmnet}
\title{Perform model selection, unbiased error estimation and the nextdoor test(p-value/model score) for functions in glmnet}
\usage{
nextdoor.glmnet(x, y, cv_glm, nams = NULL, family = "gaussian",
  lossfun = NULL, standardize = T, K = 100, B = 1000,
  alpha = 0.1, epsilon = 0.05^2, epsilon2 = 0.05^2,
  selectionType = 0, Bindex = NULL, pv = TRUE, rescale = TRUE,
  score = TRUE, B1 = 50, Bindex1 = NULL, trace = TRUE)
}
\arguments{
\item{x}{n by p training feature matrix.}

\item{y}{Length y response vector.}

\item{cv_glm}{Return from the function cv.glmnet keep = T.}

\item{nams}{a length p vector containing feature names. By default, nams = NULL, the features are named according to their column indexes in x.}

\item{family}{Response type, it can be one of "gaussian","binomial","poisson","multinomial". By default, family = "gaussian". It should be consistent with cv_glm.}

\item{lossfun}{A user-specific loss function for model evaluation. If loss = NULL, by default, we will use the deviance.}

\item{standardize}{Whether to standardize the data, standardize = T by default. It should be consistent with cv_glm.}

\item{K}{number of repetitions estimating the de-biased error.}

\item{B}{number of bootstrap repetitions estimating the p-value.}

\item{alpha}{added errors' level with added errors being covariance structure*alpha. By default, alpha = .1.}

\item{epsilon}{added errors' level  with added errors being identity*min(covariance diagonal)\*epsilon. By default, epsilon = 0.05^2.}

\item{epsilon2}{added errors' level in the Bootstrap with  added errors being min(covariance diagonal)*epsilon2.
By default, epsilon2 = 0.05^2}

\item{selectionType}{if selectionType == 0, pick the model with the smallest randomized error,
if selectionType == 1, use the 1se rule.}

\item{Bindex}{n by B index matrix for bootstrap. If Bindex == NULL,
use the randomly generated bootstrap samples, otherwise, use the provide matrix.}

\item{pv}{if pv == True, estimate the p-values.}

\item{rescale}{if rescale == True, perform the mean-rescaled Bootstrap.}

\item{score}{if score == True, provide model scores.}

\item{B1}{number of repetitions for the paired Bootstrap used to create model score.}

\item{Bindex1}{n by B1 index matrix for paired bootstrap in the model score step. If Bindex1 == NULL,
use the default Bootstrap, otherwise, use the provide matrix.}

\item{trace}{if trace == True, print the p-values as they are calculated.}
}
\value{
model0: original model sequence.

models: list of nextdoor model sequences.

errors0: original error matrix.

errors: list of nextdoor model matrices.

debiased_errors0: de-biased estimate of the prediction error for the original process.

debiased_errors: de-biased estimates of the prediction error for the processes excluding a each of the selected feature.

worsen: estimated increase in prediction error.

p_value: p values for proximity analysis.

selection_frequency: frequency of features in S being selected.

model_score: model_score for nextdoor analysis.

result_table: organized result table.
}
\description{
Perform model selection, unbiased error estimation and the nextdoor test(p-value/model score) for functions in glmnet
}
\examples{
require(glmnet)
data(prostateCancerData)
data_train = prostateCancerData$train
x = data_train$feature
y = data_train$response
nams = data_train$names; n=length(y)
set.seed(48)
cv_glm = cv.glmnet(x = x, y = y, keep = TRUE, family = "gaussian", standardize = FALSE, nfolds = 3, nlambda = 30)
R1 = nextdoor.glmnet(x = x, y = y, nams = nams, family = "gaussian", cv_glm = cv_glm, standardize = FALSE, alpha = .1,B = 1000, B1 = 20)
print(round(R1$result_table,3))
}
